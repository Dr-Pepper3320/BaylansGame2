<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no">
<title>Baylan‚Äôs Tap Game</title>
<style>
  :root{
    --bg:#0b0f18; --panel:#0e1522; --ink:#e7f1ff; --muted:#9fb6d8;
    --good:#7affb6; --accent:#76d1ff; --warn:#ffd86a; --panel2:#101827;
  }
  html,body{height:100%;margin:0;background:var(--bg);color:var(--ink);
    font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;touch-action:manipulation}
  #wrap{position:fixed;inset:0;display:flex;flex-direction:column}
  #hud{display:flex;gap:.75rem;align-items:center;justify-content:space-between;
    padding:.8rem 1rem;background:linear-gradient(180deg,rgba(255,255,255,.05),rgba(0,0,0,.05))}
  #left{display:flex;gap:.5rem;align-items:center;flex-wrap:wrap}
  .big{font-weight:700;font-size:1.25rem;letter-spacing:.3px}
  .chip{border:1px solid rgba(118,209,255,.35);background:#11182a;
    color:var(--ink);padding:.45rem .8rem;border-radius:.8rem;font-size:1rem}
  .chip:active{transform:scale(.98)}
  .chip[aria-pressed="true"]{background:#142036}
  #modeRow{display:flex;gap:.5rem;flex-wrap:wrap;justify-content:flex-end}
  #stage{position:relative;flex:1;overflow:hidden;border-top:1px solid rgba(255,255,255,.06)}
  canvas{width:100%;height:100%;display:block;touch-action:none}
  .ripple{position:absolute;pointer-events:none;border-radius:50%;border:4px solid var(--good);
    opacity:.9;transform:translate(-50%,-50%) scale(.2);animation:rip .6s ease-out forwards}
  @keyframes rip{to{opacity:0;transform:translate(-50%,-50%) scale(1)}}
  #toast{position:absolute;left:50%;top:12%;transform:translateX(-50%);padding:.5rem 1rem;
    background:rgba(0,0,0,.35);border:1px solid rgba(255,255,255,.15);border-radius:.75rem;
    opacity:0;transition:opacity .25s, transform .25s;font-size:1.25rem}
  #toast.show{opacity:1;transform:translateX(-50%) translateY(-6px)}
  #label{position:absolute;left:50%;bottom:12%;transform:translateX(-50%);
    font-weight:800;font-size:2rem;letter-spacing:.5px;text-shadow:0 2px 8px rgba(0,0,0,.5);
    opacity:0;transition:opacity .2s}
  #label.show{opacity:1}
  #shelfWrap{background:var(--panel2);border-top:1px solid rgba(255,255,255,.07)}
  #shelfBar{display:flex;gap:.5rem;overflow-x:auto;scroll-snap-type:x proximity;
    padding:.6rem 1rem}
  .sticker{min-width:84px;max-width:84px;scroll-snap-align:center;background:#0f1525;
    border:1px solid rgba(255,255,255,.08);border-radius:.9rem;padding:.5rem .5rem .6rem;text-align:center}
  .sticker .icon{font-size:2rem;line-height:1}
  .sticker .name{font-size:.9rem;opacity:.9;margin-top:.25rem;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}
  .sticker.new{outline:2px solid var(--good)}
  .peek-tip{position:absolute;left:50%;top:16%;transform:translateX(-50%);
    font-size:1.1rem;opacity:.8}
</style>
</head>
<body>
<div id="wrap">
  <div id="hud">
    <div id="left">
      <div class="big">Caught: <span id="score">0</span></div>
      <button id="resetBtn" class="chip">Reset</button>
      <button id="speedBtn" class="chip">Speed: Gentle</button>
      <button id="clearShelfBtn" class="chip">Clear Stickers</button>
    </div>
    <div id="modeRow">
      <button class="chip mode" data-mode="colors"  aria-pressed="true">Colors</button>
      <button class="chip mode" data-mode="animals" aria-pressed="false">Animals</button>
      <button class="chip mode" data-mode="count"   aria-pressed="false">Count</button>
      <button class="chip mode" data-mode="peekaboo" aria-pressed="false">Peekaboo</button>
      <button class="chip mode" data-mode="body"    aria-pressed="false">Body Parts</button>
    </div>
  </div>

  <div id="stage">
    <div id="toast" role="status" aria-live="polite">Great job!</div>
    <div id="label" aria-hidden="true"></div>
    <div id="peekTip" class="peek-tip" style="display:none;">Tap when they peek!</div>
    <canvas id="game" aria-label="Game canvas"></canvas>
  </div>

  <div id="shelfWrap">
    <div id="shelfBar" aria-label="Sticker shelf"></div>
  </div>
</div>

<script>
(() => {
  'use strict';

  /* ========= Asset base (local by default; override with ?cdn=URL ) ========= */
  const params = new URLSearchParams(location.search);
  const ASSET_BASE = (params.get('cdn') || './assets/').replace(/\/+$/,'') + '/';
  const assetUrl = p => ASSET_BASE + p.replace(/^\/+/,'');

  function loadImage(path){
    return new Promise((resolve,reject)=>{
      const img = new Image();
      img.crossOrigin = 'anonymous'; // safe on GitHub Pages/Netlify
      img.onload = ()=>resolve(img);
      img.onerror = ()=>reject(new Error('Image failed: '+assetUrl(path)));
      img.src = assetUrl(path);
    });
  }

  /* ================= Your assets ================= */
  const ASSETS = {
    animals: {
      cow:   { img:'animals/cow.png',   icon:'üêÆ', phrase:'Cow ‚Äî moo!'   },
      dog:   { img:'animals/dog.png',   icon:'üê∂', phrase:'Dog ‚Äî woof!'  },
      cat:   { img:'animals/cat.png',   icon:'üê±', phrase:'Cat ‚Äî meow!'  },
      duck:  { img:'animals/duck.png',  icon:'ü¶Ü', phrase:'Duck ‚Äî quack!' },
      sheep: { img:'animals/sheep.png', icon:'üêë', phrase:'Sheep ‚Äî baa!' }
    },
    colors: {
      red:    { img:'colors/red.png',    name:'Red',    fill:'#ff6a7b', icon:'üü•' },
      blue:   { img:'colors/blue.png',   name:'Blue',   fill:'#76d1ff', icon:'üü¶' },
      yellow: { img:'colors/yellow.png', name:'Yellow', fill:'#ffd86a', icon:'üü®' },
      green:  { img:'colors/green.png',  name:'Green',  fill:'#7affb6', icon:'üü©' },
      purple: { img:'colors/purple.png', name:'Purple', fill:'#b691ff', icon:'üü™' },
      orange: { img:'colors/orange.png', name:'Orange', fill:'#ffb46a', icon:'üüß' }
    },
    numbers: {
      1:{ img:'numbers/1.png', label:'One'   },
      2:{ img:'numbers/2.png', label:'Two'   },
      3:{ img:'numbers/3.png', label:'Three' },
      4:{ img:'numbers/4.png', label:'Four'  },
      5:{ img:'numbers/5.png', label:'Five'  }
    },
    faceIcons: { eyes:'face/eyes.png', nose:'face/nose.png', mouth:'face/mouth.png' },
    peekaboo:  { circle:'peekaboo/circle.png', square:'peekaboo/square.png', triangle:'peekaboo/triangle.png' }
  };

  const pre = { images:{} };
  async function preload(){
    for (const [id, a] of Object.entries(ASSETS.animals)){
      try { pre.images['animals/'+id] = await loadImage(a.img); } catch {}
    }
    for (const [id, c] of Object.entries(ASSETS.colors)){
      try { pre.images['colors/'+id] = await loadImage(c.img); } catch {}
    }
    for (const n of [1,2,3,4,5]){
      try { pre.images['numbers/'+n] = await loadImage(ASSETS.numbers[n].img); } catch {}
    }
    for (const [k,p] of Object.entries(ASSETS.faceIcons)){
      try { pre.images['face/'+k] = await loadImage(p); } catch {}
    }
    for (const [k,p] of Object.entries(ASSETS.peekaboo)){
      try { pre.images['peek/'+k] = await loadImage(p); } catch {}
    }
  }

  /* ================= Audio: speech + gentle chime ================= */
  let audioCtx = null;
  const ensureAudio = () => {
    if (!audioCtx) audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    if (audioCtx.state === 'suspended') audioCtx.resume();
  };
  function chime(){
    ensureAudio();
    const now = audioCtx.currentTime;
    const notes = [523.25,659.25,783.99]; // C5 E5 G5
    notes.forEach((f,i)=>{
      const o = audioCtx.createOscillator(), g = audioCtx.createGain();
      o.type='sine'; o.frequency.value=f;
      g.gain.value=0.0001;
      g.gain.exponentialRampToValueAtTime(0.2, now+0.02+i*0.05);
      g.gain.exponentialRampToValueAtTime(0.0001, now+0.25+i*0.05);
      o.connect(g).connect(audioCtx.destination);
      o.start(now+i*0.05); o.stop(now+0.35+i*0.05);
    });
  }
  function speak(text){
    try{
      const u = new SpeechSynthesisUtterance(text);
      u.rate = 0.9; u.pitch = 1.0;
      speechSynthesis.cancel(); speechSynthesis.speak(u);
    } catch { chime(); }
  }

  /* ================= Stickers ================= */
  const SHELF_KEY = 'toddler.tap.stickers.v4';
  const shelfEl = document.getElementById('shelfBar');
  let stickers = new Set(JSON.parse(localStorage.getItem(SHELF_KEY) || '[]'));
  const saveShelf = () => localStorage.setItem(SHELF_KEY, JSON.stringify([...stickers]));
  function addSticker(id, name, iconOrImg){
    const key = id + '|' + name + '|' + (iconOrImg||'');
    if (!stickers.has(key)){
      stickers.add(key); saveShelf(); renderShelf(key);
      flashToast('New sticker!');
    }
  }
  function clearShelf(){ stickers = new Set(); saveShelf(); renderShelf(); }
  function renderShelf(newKey=null){
    shelfEl.innerHTML = '';
    [...stickers].forEach(k=>{
      const [id,name,icon] = k.split('|');
      const card = document.createElement('div');
      card.className = 'sticker' + (newKey===k?' new':'');
      if (icon && (icon.endsWith('.png') || icon.endsWith('.jpg') || icon.startsWith('http'))){
        card.innerHTML = `<div class="icon"><img src="${icon}" style="width:2.2rem;height:2.2rem;object-fit:contain"/></div><div class="name">${name}</div>`;
      } else {
        card.innerHTML = `<div class="icon">${icon || '‚≠ê'}</div><div class="name">${name}</div>`;
      }
      shelfEl.appendChild(card);
      if (newKey===k) setTimeout(()=>card.classList.remove('new'), 900);
    });
    if (stickers.size===0){
      const empty = document.createElement('div');
      empty.style.opacity='0.7'; empty.textContent='Collect stickers by tapping!';
      shelfEl.appendChild(empty);
    }
  }
  renderShelf();

  /* ================= Canvas + state ================= */
  const canvas = document.getElementById('game');
  const stage  = document.getElementById('stage');
  const ctx    = canvas.getContext('2d', { alpha:false });
  const labelEl= document.getElementById('label');
  const toast  = document.getElementById('toast');
  const scoreEl= document.getElementById('score');
  const peekTip= document.getElementById('peekTip');

  let DPR=1, W=0, H=0;
  function resize(){
    const r = window.devicePixelRatio || 1;
    DPR = Math.max(1, Math.min(3, r));
    const rect = stage.getBoundingClientRect();
    W = Math.max(320, rect.width|0);
    H = Math.max(320, rect.height|0);
    canvas.width = (W*DPR)|0; canvas.height=(H*DPR)|0;
    ctx.setTransform(DPR,0,0,DPR,0,0); clampMover();
  }
  addEventListener('resize', resize, {passive:true});
  new ResizeObserver(resize).observe(stage);

  const COLOR_KEYS = Object.keys(ASSETS.colors);
  const ANIMAL_KEYS = Object.keys(ASSETS.animals);
  const COUNT_SEQ = [1,2,3,4,5];

  // Single mover used in all modes
  const mover = {
    x:200, y:200, r:80, w:160, h:160,
    vx:120, vy:100,
    colorKey: COLOR_KEYS[0], animalKey: ANIMAL_KEYS[0], countIndex: 0
  };
  function clampMover(){
    mover.x = Math.max(mover.r, Math.min(W-mover.r, mover.x));
    mover.y = Math.max(mover.r, Math.min(H-mover.r, mover.y));
  }

  // Peekaboo sequence
  const covers = []; // filled on resize
  const peek = {
    activeCover: 0,
    progress: 0,   // 0 = hidden behind; 1 = fully popped
    dir: 1,        // +1 pop up, -1 go down
    nextFlip: 0
  };

  function buildCovers(){
    covers.length = 0;
    const imgs = [
      pre.images['peek/circle'],
      pre.images['peek/square'],
      pre.images['peek/triangle']
    ].filter(Boolean);

    const n = 6, step=W/(n+1), s=120;
    for(let i=0;i<n;i++){
      covers.push({
        x: step*(i+1),
        y: H*0.55 + Math.sin((i+1)*1.3)*20,
        s,
        img: imgs[i % Math.max(1, imgs.length)]
      });
    }
    peek.activeCover = Math.floor(Math.random()*covers.length);
  }

  let mode = 'colors'; // colors | animals | count | peekaboo | body
  let score = 0;
  let speedScale = 0.7;

  function pickNext(){
    if (mode==='colors') mover.colorKey = COLOR_KEYS[(Math.random()*COLOR_KEYS.length)|0];
    if (mode==='animals') mover.animalKey = ANIMAL_KEYS[(Math.random()*ANIMAL_KEYS.length)|0];
    if (mode==='count') mover.countIndex = (mover.countIndex+1) % COUNT_SEQ.length;
    if (mode==='peekaboo'){
      // choose a new cover to pop from
      peek.activeCover = Math.floor(Math.random()*covers.length);
      peek.dir = 1; peek.progress = 0;
      peek.nextFlip = performance.now() + 900 + Math.random()*1200;
    }
  }

  /* ================= Drawing ================= */
  function drawBg(){
    const g1 = ctx.createLinearGradient(0,0,0,H);
    g1.addColorStop(0,'#0d1321'); g1.addColorStop(1,'#0a0f1a');
    ctx.fillStyle=g1; ctx.fillRect(0,0,W,H);
  }

  // SIMPLE FACE (used for peekaboo pop + body mode base)
  function drawSimpleFace(x,y,scale=1){
    ctx.fillStyle = '#ffd86a';
    ctx.beginPath(); ctx.ellipse(x, y, 80*scale, 80*scale, 0, 0, Math.PI*2); ctx.fill();

    ctx.fillStyle = '#0b0f18';
    ctx.beginPath(); ctx.arc(x-28*scale, y-15*scale, 12*scale, 0, Math.PI*2); ctx.fill();
    ctx.beginPath(); ctx.arc(x+28*scale, y-15*scale, 12*scale, 0, Math.PI*2); ctx.fill();

    ctx.lineWidth = 10*scale; ctx.lineCap='round'; ctx.strokeStyle='#0b0f18';
    ctx.beginPath(); ctx.moveTo(x-36*scale, y+25*scale);
    ctx.quadraticCurveTo(x, y+50*scale, x+36*scale, y+25*scale); ctx.stroke();
  }

  function drawColors(){
    const key = mover.colorKey, ent = ASSETS.colors[key];
    const img = pre.images['colors/'+key];
    if (img){
      ctx.drawImage(img, mover.x - 70, mover.y - 70, 140, 140);
    } else {
      ctx.fillStyle = ent.fill;
      ctx.beginPath(); ctx.ellipse(mover.x, mover.y, 60, 60, 0, 0, Math.PI*2); ctx.fill();
    }
  }
  function drawAnimals(){
    const key = mover.animalKey, img = pre.images['animals/'+key];
    if (img) ctx.drawImage(img, mover.x - 70, mover.y - 70, 140, 140);
    else {
      const icon = ASSETS.animals[key]?.icon || '‚≠ê';
      ctx.font = '56px system-ui, -apple-system, Segoe UI, Roboto, Arial';
      ctx.textAlign='center'; ctx.textBaseline='middle';
      ctx.fillText(icon, mover.x, mover.y);
    }
  }
  function drawCount(){
    const n = COUNT_SEQ[mover.countIndex];
    const img = pre.images['numbers/'+n];
    if (img) ctx.drawImage(img, mover.x - 60, mover.y - 60, 120, 120);
    else {
      ctx.font = 'bold 64px system-ui, -apple-system, Segoe UI, Roboto, Arial';
      ctx.textAlign='center'; ctx.textBaseline='middle'; ctx.fillStyle = '#ffffff';
      ctx.fillText(String(n), mover.x, mover.y);
    }
  }

  // Body: always draw one face, then overlay feature PNGs
  function drawBody(){
    drawSimpleFace(mover.x, mover.y, 1);
    const scale = 1;
    const eyes = pre.images['face/eyes'];
    const nose = pre.images['face/nose'];
    const mouth= pre.images['face/mouth'];
    if (eyes){
      const w=50, h=30;
      ctx.drawImage(eyes, mover.x - 28 - w/2, mover.y - 15 - h/2, w, h);
      ctx.drawImage(eyes, mover.x + 28 - w/2, mover.y - 15 - h/2, w, h);
    }
    if (nose)  ctx.drawImage(nose,  mover.x - 14, mover.y - 14, 28, 28);
    if (mouth) ctx.drawImage(mouth, mover.x - 35, mover.y + 22 - 20, 70, 40);
  }

  // Peekaboo: draw shapes, then face *popping* from behind active cover
  function drawPeekaboo(t){
    // background decorations (covers)
    covers.forEach((c,i)=>{
      if (!c.img){
        // fallback: smooth rounded rect / circle
        ctx.save(); ctx.globalAlpha = 0.9;
        ctx.fillStyle = i%2? '#2a375a' : '#1b2644';
        if (i%2){ ctx.beginPath(); ctx.roundRect(c.x-c.s/2, c.y-c.s/2, c.s, c.s*0.78, 18); ctx.fill(); }
        else    { ctx.beginPath(); ctx.arc(c.x, c.y, c.s*0.45, 0, Math.PI*2); ctx.fill(); }
        ctx.restore();
      } else {
        ctx.save(); ctx.globalAlpha = 0.95;
        ctx.drawImage(c.img, c.x - c.s/2, c.y - c.s/2, c.s, c.s);
        ctx.restore();
      }
    });

    // animate progress
    const speed = 0.035; // easing speed
    peek.progress += peek.dir * speed;
    if (peek.progress > 1){ peek.progress = 1; }
    if (peek.progress < 0){ peek.progress = 0; }

    const c = covers[peek.activeCover];
    if (!c) return;

    // pop position (easeOutBack feel)
    const ease = (p)=> { const s=1.70158; p = Math.min(1, Math.max(0,p)); return 1 + ( --p * p * ((s+1)*p + s) ); };
    const p = ease(peek.progress);

    // y offset: start hidden, pop above the top edge of the cover
    const hiddenY = c.y + c.s*0.25;
    const shownY  = c.y - c.s*0.15;
    const faceY   = hiddenY + (shownY - hiddenY) * p;
    const faceX   = c.x;

    // draw face first...
    drawSimpleFace(faceX, faceY, 0.9);

    // ...then draw the cover AGAIN to occlude lower part (so it looks like behind)
    if (c.img){
      ctx.drawImage(c.img, c.x - c.s/2, c.y - c.s/2, c.s, c.s);
    } else {
      ctx.save(); ctx.fillStyle='#1b2644'; ctx.globalAlpha=0.95;
      ctx.beginPath(); ctx.roundRect(c.x-c.s/2, c.y-c.s/2, c.s, c.s*0.78, 18); ctx.fill();
      ctx.restore();
    }

    // auto flip timing
    if (t > peek.nextFlip){
      if (peek.dir > 0){ // reached up ‚Üí go down soon
        peek.dir = -1;
        peek.nextFlip = t + 500 + Math.random()*600;
      } else { // reached down ‚Üí choose next and pop again
        peek.activeCover = Math.floor(Math.random()*covers.length);
        peek.dir = 1; peek.progress = 0;
        peek.nextFlip = t + 800 + Math.random()*1000;
      }
    }
  }

  function draw(t){
    drawBg();
    if (mode==='colors')   drawColors();
    if (mode==='animals')  drawAnimals();
    if (mode==='count')    drawCount();
    if (mode==='body')     drawBody();
    if (mode==='peekaboo') drawPeekaboo(t||performance.now());
  }

  /* ================= Loop & movement ================= */
  let lastT=0, nudgeAt=0;
  function step(t){
    requestAnimationFrame(step);
    if (!lastT){ lastT=t; return; }
    const dt = Math.min(0.032, (t-lastT)/1000);
    lastT = t;

    if (mode!=='peekaboo'){ // move only the current sprite; peekaboo is stationary pop
      mover.x += mover.vx*dt; mover.y += mover.vy*dt;
      if (mover.x < mover.r){ mover.x=mover.r; mover.vx=Math.abs(mover.vx); }
      if (mover.x > W-mover.r){ mover.x=W-mover.r; mover.vx=-Math.abs(mover.vx); }
      if (mover.y < mover.r){ mover.y=mover.r; mover.vy=Math.abs(mover.vy); }
      if (mover.y > H-mover.r){ mover.y=H-mover.r; mover.vy=-Math.abs(mover.vy); }

      if (t>nudgeAt){
        nudgeAt = t + 1200 + Math.random()*1800;
        mover.vx += (Math.random()*100 - 50);
        mover.vy += (Math.random()*100 - 50);
        const max = speedScale * 220;
        mover.vx = Math.max(-max, Math.min(max, mover.vx));
        mover.vy = Math.max(-max, Math.min(max, mover.vy));
      }
    }

    draw(t);
  }

  /* ================= Feedback & input ================= */
  function showRipple(x,y){
    const el = document.createElement('div');
    el.className='ripple'; el.style.left=x+'px'; el.style.top=y+'px';
    stage.appendChild(el); setTimeout(()=>el.remove(),650);
  }
  function flashToast(msg){
    toast.textContent = msg; toast.classList.add('show');
    clearTimeout(flashToast._t); flashToast._t = setTimeout(()=>toast.classList.remove('show'), 600);
  }
  function showLabel(text){
    labelEl.textContent = text; labelEl.classList.add('show');
    clearTimeout(showLabel._t); showLabel._t = setTimeout(()=>labelEl.classList.remove('show'), 900);
  }

  function hitBodyPart(x,y){
    // Hit test around typical feature locations on the face in Body mode
    const rx = x - mover.x, ry = y - mover.y;
    const eyeL = (rx+28)**2 + (ry+15)**2 <= 20**2;
    const eyeR = (rx-28)**2 + (ry+15)**2 <= 20**2;
    const mouth= ry>10 && ry<46 && Math.abs(rx)<50;
    const nose = rx*rx + ry*ry <= 12**2;
    if (eyeL || eyeR) return {id:'eyes', name:'Eyes', iconPath:assetUrl(ASSETS.faceIcons.eyes)};
    if (nose)         return {id:'nose', name:'Nose', iconPath:assetUrl(ASSETS.faceIcons.nose)};
    if (mouth)        return {id:'mouth',name:'Mouth',iconPath:assetUrl(ASSETS.faceIcons.mouth)};
    return null;
  }

  let lastTapTime = 0;
  function onPointerDown(ev){
    if (ev.isPrimary === false) return;
    const now = performance.now();
    if (now - lastTapTime < 220) return;
    lastTapTime = now;

    const rect = canvas.getBoundingClientRect();
    const x = ev.clientX - rect.left, y = ev.clientY - rect.top;

    if (mode==='peekaboo'){
      // consider a tap near the active cover a ‚Äúcatch‚Äù
      const c = covers[peek.activeCover]; if (!c) return;
      const dx = x - c.x, dy = y - c.y;
      const inside = (dx*dx + dy*dy) <= (c.s*0.5)**2; // circle-ish target
      if (!inside) return;

      speak('Peekaboo!'); showLabel('Peekaboo!');
      addSticker('peekaboo','Peekaboo','üôà');
      score++; scoreEl.textContent = String(score);
      flashToast('Great job!'); showRipple(c.x, c.y);

      // force hide then schedule next pop
      peek.dir = -1; peek.nextFlip = now + 500;
      return;
    }

    // Other modes: only count tap if hit the moving sprite (no ball behind)
    let hit=false;
    if (mode==='colors' || mode==='animals'){
      hit = ((x-mover.x)**2 + (y-mover.y)**2) <= (70**2);
    } else if (mode==='count'){
      hit = ((x-mover.x)**2 + (y-mover.y)**2) <= (60**2);
    } else if (mode==='body'){
      // face radius
      hit = ((x-mover.x)**2 + (y-mover.y)**2) <= (80**2);
    }
    if (!hit) return;

    let speakText=null, labelText=null, sticker=null;
    if (mode==='colors'){
      const key = mover.colorKey, ent = ASSETS.colors[key];
      speakText = ent.name + '!'; labelText = ent.name;
      sticker = ['color_'+key, ent.name, ent.icon];
    }
    else if (mode==='animals'){
      const key = mover.animalKey, ent = ASSETS.animals[key];
      speak(ent?.phrase || 'Great job!'); labelText = ent?.name || key;
      const iconPath = pre.images['animals/'+key] ? assetUrl(ent.img) : (ent?.icon || 'üêæ');
      sticker = ['animal_'+key, ent?.name || key, iconPath];
    }
    else if (mode==='count'){
      const n = COUNT_SEQ[mover.countIndex];
      const word = ASSETS.numbers[n]?.label || String(n);
      speak(word); labelText = word;
      const iconPath = pre.images['numbers/'+n] ? assetUrl(ASSETS.numbers[n].img) : 'üî¢';
      sticker = ['count_'+n, String(n), iconPath];
    }
    else if (mode==='body'){
      const part = hitBodyPart(x,y);
      if (!part) return;
      speakText = part.name + '!'; labelText = part.name;
      sticker = ['body_'+part.id, part.name, part.iconPath || '‚≠ê'];
    }

    if (speakText) speak(speakText); else chime();
    if (labelText) showLabel(labelText);
    if (sticker) addSticker(...sticker);

    score++; scoreEl.textContent = String(score);
    showRipple(mover.x, mover.y);
    flashToast('Great job!');

    // bounce + new target
    mover.vx = (Math.random()<.5?-1:1) * (160 + Math.random()*160) * speedScale;
    mover.vy = (Math.random()<.5?-1:1) * (140 + Math.random()*140) * speedScale;
    pickNext();
  }
  canvas.addEventListener('pointerdown', onPointerDown, {passive:true});
  addEventListener('pointerdown', ensureAudio, {once:true});

  /* ================= Controls ================= */
  const resetBtn = document.getElementById('resetBtn');
  const speedBtn = document.getElementById('speedBtn');
  const clearShelfBtn = document.getElementById('clearShelfBtn');
  const modeBtns = Array.from(document.querySelectorAll('.mode'));

  resetBtn.addEventListener('click', () => { score=0; scoreEl.textContent='0'; flashToast('Reset!'); });
  speedBtn.addEventListener('click', () => {
    speedScale = speedScale===0.7 ? 1.0 : 0.7;
    speedBtn.textContent = 'Speed: ' + (speedScale===0.7 ? 'Gentle' : 'Normal');
  });
  clearShelfBtn.addEventListener('click', () => { clearShelf(); flashToast('Cleared'); });

  modeBtns.forEach(btn=>{
    btn.addEventListener('click', ()=>{
      modeBtns.forEach(b=>b.setAttribute('aria-pressed','false'));
      btn.setAttribute('aria-pressed','true');
      mode = btn.dataset.mode;
      if (mode==='peekaboo'){ peekTip.style.display='block'; }
      else { peekTip.style.display='none'; }
      pickNext();
      if (mode==='colors')  speak('Colors');
      if (mode==='animals') speak('Animals');
      if (mode==='count')   { speak('Let\'s count!'); mover.countIndex=0; }
      if (mode==='peekaboo') speak('Peekaboo!');
      if (mode==='body')     speak('Body parts');
    });
  });

  /* ================= Start ================= */
  async function init(){
    resize();
    await preload();
    buildCovers();
    mover.x = W*0.3 + Math.random()*W*0.4;
    mover.y = H*0.3 + Math.random()*H*0.4;
    pickNext();
    requestAnimationFrame(step);
  }
  setTimeout(init, 0);

  /* =============== UI helpers =============== */
  function flashToast(msg){
    const el = document.getElementById('toast');
    el.textContent = msg; el.classList.add('show');
    clearTimeout(flashToast._t); flashToast._t = setTimeout(()=>el.classList.remove('show'), 600);
  }
  function showLabel(text){
    const el = document.getElementById('label');
    el.textContent = text; el.classList.add('show');
    clearTimeout(showLabel._t); showLabel._t = setTimeout(()=>el.classList.remove('show'), 900);
  }
  const stage = document.getElementById('stage');
  function showRipple(x,y){
    const el = document.createElement('div');
    el.className='ripple'; el.style.left=x+'px'; el.style.top=y+'px';
    stage.appendChild(el); setTimeout(()=>el.remove(),650);
  }
})();
</script>
</body>
</html>
